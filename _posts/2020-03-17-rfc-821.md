---
layout: post
title: "RFC-821 번역 (KOR)"
tags: [rfc, rfc-821, 번역]
comments: true
---

> 이 포스트는 RFC-821을 번역한 문서입니다.
>
> 원문 URL : https://tools.ietf.org/html/rfc821

# 1. Introduction

```
Simple Mail Transfer Protocol(SMTP)의 목적은 메일을 신뢰성 있고 효율적으로 전송하는 것입니다.
SMTP는 특정 전송 하위시스템과 독립적이며 신뢰할 수 있는 정렬된 데이터 스트림 채널이 필요합니다.
부록 A, B, C 및 D는 다양한 전송 서비스에서 SMTP를 사용하는 방법을 설명합니다. 
용어사전(Glossary)은 문서에서 사용 된 용어의 정의를 제공합니다.
```

SMTP의 중요한 기능은 전송 서비스 환경에서 메일을 릴레이하는 기능입니다.
전송 서비스는 IPCE(interprocess Communication Environment)를 제공합니다. 
IPCE는 하나의 네트워크, 여러 네트워크 또는 네트워크의 하위 집합을 포함 할 수 있습니다.

> 전송 시스템(또는 IPCE)이 네트워크와 일대일 관계가 아니라는 것을 깨닫는 것이 중요합니다.

프로세스는 상호 알려진 IPCE를 통해 다른 프로세스와 직접 통신 할 수 있습니다.
메일은 응용 프로그램 또는 프로세스 간 통신의 사용입니다.
메일은 두 개 이상의 IPCE에 연결된 프로세스를 통해 릴레이함으로써 서로 다른 IPCE의 프로세스 간에 통신할 수 있습니다.
보다 구체적으로는, 메일은 두 전송 시스템의 호스트에 의해 서로 다른 전송 시스템의 호스트들 사이에서 중계될 수 있습니다.

---

# 2. The SMTP Model

```
SMTP 디자인은 다음과 같은 통신 모델을 기반으로 합니다:
사용자 메일 요청의 결과로, sender-SMTP는 reciever-SMTP로의 양방향 전송 채널을 설정합니다.
receiver-SMTP는 최종 목적지 또는 중간 단계일 수 있습니다.
SMTP 명령은 sender-SMTP에 의해 생성되고 receiver-SMTP에 전송됩니다.
SMTP 응답은 receiver-SMTP에서 명령에 대한 응답으로 sender-SMTP로 전송됩니다.
```

전송 채널이 설정되면, SMTP-sender는 메일의 발신자를 나타내는 MAIL 명령을 전송합니다.
SMTP-receiver가 메일을 수신할 수 있는 경우, "OK"로 응답합니다.
그런 다음 SMTP-sender는 메일의 수신자를 식별하는 RCPT 명령을 보냅니다.
SMTP 수신자가 해당 수신자에 대한 메일을 수락할 수 있는 경우, 해당 수신자에 대해 OK로 응답하며, 그렇지 않은 경우 해당 수신자를 거부합니다(전체 메일 트랜잭션에 대한 거부는 아닙니다).
SMTP-sender 및 SMTP-receiver는 여러 수신자를 협의할 수 있습니다.
수신자가 협의된 경우 SMTP-sender는 메일 데이터를 전송하고, 특수한 순서로 종료합니다.
SMTP 수신자가 메일 데이터를 성공적으로 처리하면 "OK"로 응답합니다. 
이러한 대화는 한 번에 하나씩 처리됩니다.

![2020-03-17-1](https://github.com/Leeheejin/leeheejin.github.io/blob/master/images/2020-03-17/1.png?raw=true) 
Model for SMTP Use
SMTP는 메일 전송을 위한 메커니즘을 제공합니다.
두 호스트가 동일한 전송 서비스에 연결될 때 또는 
소스 및 대상 호스트가 동일한 전송 서비스에 연결되지 않을 때 
하나 이상의 릴레이 SMTP 서버를 통해 전송 사용자의 호스트에서 수신 사용자의 호스트로 직접 이동합니다.

릴레이 기능을 제공할 수 있으려면 SMTP 서버에 최종 목적지 호스트 이름과 목적지 메일박스 이름을 제공해야 합니다.
MAIL 명령의 인수는 메일을 보낸 사람을 지정하는 reverse-path입니다.
RCPT 명령에 대한 인수는 메일이 누구에게 보내는지 지정하는 forward-path입니다.
forward-path는 소스 경로인 반면, reverse-path는 반송 경로(중계된 메시지로 오류가 발생할 때 발신자에게 메시지를 반환하는 데 사용될 수 있습니다)입니다.

동일한 메시지가 여러 수신자에게 전송되면 SMTP는 동일한 수신 호스트의 모든 수신자에 대한 데이터 사본 중 하나만 전송하도록 권장합니다.

메일 명령과 응답은 엄격한 구문을 가지고 있습니다.
응답에는 숫자 코드가 포함되어 있습니다. 명령 및 응답의 전체 목록은 사양에 대한 4절에 설명되어 있습니다.
명령과 응답은 대소문자에 민감하지 않습니다. 즉 명령어 또는 응답은 대문자, 소문자 또는 대소문자의 혼합일 수 있습니다.
메일박스 사용자 이름에 대해서는 이 항목은 예외입니다.
일부 호스트의 경우 사용자 이름은 대소 문자를 구분하며 SMTP 구현에서는 사용자 이름이 메일박스 인수에 표시 될 때 대소문자를 보존해야합니다. 
호스트 이름은 대소문자를 구분하지 않습니다.
명령어 및 응답은 ASCII 문자 집합의 문자로 구성됩니다. [1]
전송 서비스가 8-비트 바이트(옥텟) 전송 채널을 제공 할 때 각각의 7-비트 문자는 오른쪽으로 정렬되고, 상위 비트는 0으로 지워져 전송됩니다.
명령이나 응답의 형태를 지정할 때, 인수(또는 특수 기호)는 메타언어 변수(또는 상수)로 표시됩니다(예를 들어, \<string> 또는 <reverse-path>).
여기서 각 괄호는 이러한 변수가 메타언어 변수임을 나타냅니다.
그러나 일부 인수는 문자 그대로 꺾쇠 괄호를 사용합니다. 예를 들어 실제 역방향 경로는 꺾쇠 괄호로 묶습니다. 예를 들어 "<John.Smith@USC-ISI.ARPA>"는 <reverse-path>의 인스턴스 입니다.

---

# 3. The SMTP Procedures

```
이 절에서는 SMTP에 사용되는 절차를 여러 부분으로 설명합니다.
먼저 메일 트랜잭션으로 정의된 기본 메일 절차를 설명합니다.
다음은 메일 발송, 메일박스 이름 확인 및 메일링 목록 확장, 메일박스 대신 또는 메일박스와 함께 터미널로 보내는 것, 개폐 교환에 대한 설명입니다.
이 절의 끝부분에는 릴레이에 대한 주석, 메일 도메인에 대한 주석 및 역할 변경에 대한 논의가 있습니다.
이 절에서는 부분적인 명령 및 응답 시퀀스의 예를 제공하며 몇 가지 완전한 시나리오가 부록 F에 나와 있습니다.
```

---

## 3.1. Mail

```
SMTP 메일 트랜잭션에는 세 단계가 있습니다.
트랜잭션은 발신자 식별 정보를 제공하는 MAIL 명령으로 시작됩니다.
수신자 정보를 제공하는 일련의 하나 이상의 RCPT 명령이 이어집니다.
그런 다음 DATA 명령이 메일 데이터를 제공합니다.
그리고 마지막으로 메일 데이터 표시기의 끝은 트랜잭션을 확인시킵니다.
```

1. 절차의 첫 번째 단계는 MAIL 명령이고, 소스 메일박스를 포함합니다.
`MAIL <SP> FROM:<reverse-path> <CRLF>`
이 명령은 SMTP-receiver에게 새 메일 트랜잭션이 시작되고 수신자 또는 메일 데이터를 포함한 모든 상태 테이블과 버퍼를 재 설정 하도록 지시합니다.
그것은 오류를 보고하는 데 사용될 수 있는 reverse-path를 제공합니다. 승인되면 receiver-SMTP는 "250 OK"응답을 반환합니다.
\<reverse-path>는 단순한 메일박스 이상을 포함 할 수 있습니다.
\<reverse-path>는 호스트 및 메일박스의 역방향 소스 라우팅 목록입니다. 첫 번째 호스트는 이 명령을 보내는 호스트여야 합니다.

2. 절차의 두 번째 단계는 RCPT 명령입니다.
`RCPT <SP> TO:<forward-path> <CRLF>`
이 명령은 수신자 한 명을 식별하는 forward-path를 제공합니다.수락되면 receiver-SMTP는 "250 OK"을 반환하고 forward-path를 저장합니다.
수신자가 알 수 없는 경우 receiver-SMTP는 550 실패 응답을 반환합니다. 이 절차의 두 번째 단계는 여러 번 반복될 수 있습니다.

> <forward-path>는 단순한 메일박스 이상을 포함 할 수 있습니다.
>
> <forward-path>는 호스트 및 대상 메일박스의 소스 라우팅 목록입니다. 첫 번째 호스트는 이 명령을 받는 호스트여야 합니다.

3. 절차의 세 번째 단계는 DATA 명령입니다.
`DATA <CRLF>`
승인될 경우 SMTP 서버는 354 중간 응답을 반환하고 메일 데이터의 끝까지의 모든 데이터를 메시지 텍스트로 간주합니다.
텍스트의 끝을 수신하고 저장하면 SMTP 수신자는 "250 OK " 응답을 보냅니다.
메일 데이터는 전송 채널에서 전송되므로, 명령 및 응답 대화를 재개할 수 있도록 메일 데이터의 끝을 표시해야 합니다. SMTP는 마침표만 포함하는 행을 전송하여 메일 데이터의 끝을 표시합니다.
이것이 사용자의 텍스트를 방해하지 않도록 투명성 절차가 사용됩니다.
메일 데이터에는 날짜, 제목, To, Cc, From과 같은 메모 헤더 항목이 포함되어 있습니다. 2
메일 데이터 끝 표시기는 메일 트랜잭션을 확인하고 receiver-SMTP에게 저장된 수신자 및 메일 데이터를 처리하도록 지시합니다. 수락되면, receiver-SMTP는 "250 OK"을 반환합니다.
메일 트랜잭션이 불완전하거나(예를 들어 수신자가 없음), 리소스를 사용할 수 없는 경우에만 데이터 명령이 실패해야 합니다.
위의 절차는 메일 트랜잭션의 예입니다.
이 명령은 위에서 설명한 순서로만 사용해야 합니다.
아래는 메일 트랜잭션에서 이러한 명령의 사용을 보여줍니다.

* [예제 1]

> 이 SMTP 예는 호스트 Alpha.ARPA 에서 Smith가 호스트 Beta.ARPA의 Jones, Green, Brown에게 보낸 메일을 보여줍니다.
>
> 여기서 우리는 호스트 Alpha가 호스트 Beta와 직접 접촉한다고 가정합니다.

```
S: MAIL FROM:<Smith@Alpha.ARPA>
R: 250 OK
S: RCPT TO:<Jones@Beta.ARPA>
R: 250 OK
S: RCPT TO:<Green@Beta.ARPA>
R: 550 No such user here
S: RCPT TO:<Brown@Beta.ARPA>
R: 250 OK
S: DATA
R: 354 Start mail input; end with <CRLF>.<CRLF>
S: Blah blah blah...
S: ...etc. etc. etc.
S: <CRLF>.<CRLF>
R: 250 OK
```

* Jones와 Brown에게 메일이 접수되었습니다. Green은 Beta 호스트에 메일박스를 가지고 있지 않았습니다.

---

## 3.2. Forwarding

forward-path의 목적지 정보가 부정확한 경우도 있지만, receiver-SMTP는 정확한 목적지를 알고 있습니다.
이 경우 발신자가 올바른 목적지에 연락할 수 있도록 다음 응답 중 하나를 사용해야 합니다.
1. `251 User not local; <forward-path> 로 전달`
이 응답은 receiver-SMTP가 사용자의 메일박스가 다른 호스트에 있다는 것을 알고 있으며 향후 사용할 올바른 forward-path를 표시한다는 것을 나타냅니다.
호스트 또는 사용자 또는 둘 다 다를 수 있습니다. 수신자는 메시지 전달을 책임집니다.

2. `551 User not local; <forward-path>를 시도해 보십시오`
이 응답은 receiver-SMTP가 사용자의 메일박스가 다른 호스트에 있다는 것을 알고 올바른 forward-path를 표시한다는 것을 나타냅니다.
호스트 또는 사용자 또는 둘 다 다를 수 있습니다. 수신자는 이 사용자에 대한 메일 수락을 거부하고 발신자는 제공된 정보에 따라 메일을 리다이렉션 하거나 원래 사용자에게 오류 응답을 반환해야 합니다.
예제2는 이러한 응답의 사용을 예시로 보여줍니다.

* [예제2]

```
Either
S: RCPT TO:<Postel@USC-ISI.ARPA>
R: 251 User not local; will forward to <Postel@USC-ISIF.ARPA>
Or
S: RCPT TO:<Paul@USC-ISIB.ARPA>
R: 551 User not local; please try <Mockapetris@USC-ISIF.ARPA>
```

---

## 3.3. Verifying And Expanding

SMTP는 사용자 이름을 확인하거나 메일링 목록을 확장하는 추가 기능, 명령을 제공합니다.
이것은 문자열 인수를 가지는 VRFY 및 EXPN 명령으로 수행됩니다.
VRFY 명령의 경우 문자열은 사용자 이름이며 응답에는 사용자의 전체 이름이 포함될 수 있으며 사용자의 메일박스를 포함해야 합니다.
EXPN 명령의 경우 문자열은 메일링 목록을 식별하고 여러 줄의 응답에는 사용자의 전체 이름이 포함될 수 있으며 메일링 목록에 있는 메일박스를 제공해야 합니다.
**사용자 이름**은 모호한 용어로 의도적으로 사용됩니다. 호스트가 다른 문자열을 허용되는 **사용자 이름**으로 인식하도록 선택하는 경우. 호스트가 VRFY 또는 EXPN 명령을 구현하는 경우 로컬 메일박스는 "사용자 이름"으로 인식되어야합니다.
어떤 호스트에서는 하나의 메일박스에 대한 메일링 리스트와 별칭의 구분이 약간 모호합니다.
공통 데이터 구조는 두 가지 유형의 항목을 모두 포함할 수 있고, 하나의 메일박스에 대한 메일링 리스트를 가질 수 있기 때문입니다.
메일링 리스트를 검증하기 위한 요청이 이루어진 경우, 주소가 지정된 메시지를 수신하면 리스트에 있는 모든 사람에게 전달될 경우 긍정적인 응답이 주어질 수 있으며, 그렇지 않으면 오류가 보고되어야 합니다(예: `550 That is a mailing list, not a user`).
사용자 이름을 확장하도록 요청한 경우 하나의 이름을 포함하는 목록을 반환하여 긍정적인 응답 혹은 오류를 보고 할 수 있습니다(예 : `550 That is a user name, not a mailing list`).
여러 줄로 된 응답(EXPN의 경우 보통)의 경우 응답의 각 줄에 정확히 하나의 메일박스를 지정해야 합니다.
애매한 요청 (예 : "VRFY Smith")의 경우 Smith가 두 개인 경우 응답은 `553 User ambiguous`여야 합니다.
사용자 이름을 확인하는 경우는 예제3에서와 같이 간단합니다.

* [예제3]

```
Either
S: VRFY Smith
R: 250 Fred Smith <Smith@USC-ISIF.ARPA>
Or
S: VRFY Smith
R: 251 User not local; will forward to <Smith@USC-ISIQ.ARPA>
Or
S: VRFY Jones
R: 550 String does not match anything.
Or
S: VRFY Jones
R: 551 User not local; please try <Jones@USC-ISIQ.ARPA>
Or
S: VRFY Gourzenkyinplatz
R: 553 User ambiguous.
```

> 메일박스 목록을 확장하는 경우 예제4와 같이 다중 응답이 필요합니다.

* [예제4]

```
* Either
S: EXPN Example-People
R: 250-Jon Postel <Postel@USC-ISIF.ARPA>
R: 250-Fred Fonebone <Fonebone@USC-ISIQ.ARPA>
R: 250-Sam Q. Smith <SQSmith@USC-ISIQ.ARPA>
R: 250-Quincy Smith <@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
R: 250-<joe@foo-unix.ARPA>
R: 250 <xyz@bar-unix.ARPA>
Or
S: EXPN Executive-Washroom-List
R: 550 Access Denied to You.
```

> 사용자 이름과 메일박스 목록 개념을 다양하게 구현하기 때문에 VRFY 및 EXPN 명령의 문자열 인수를 더 이상 제한할 수 없습니다.
>
> 일부 시스템에서는 EXPN 명령의 인수가 메일 목록을 포함하는 파일의 파일 이름이 되는 것이 적절할 수 있지만, 인터넷에는 다양한 파일 명명 규칙이 있습니다.
>
> VRFY 및 EXPN 명령은 최소 구현(4.5.1절 참조)에 포함되어 있지 않으며 구현시 릴레이에서 작동 하지 않을 수 있습니다.

---

## 3.4. Sending And Mailing

```
SMTP의 주요 목적은 사용자의 메일박스에 메시지를 전달하는 것입니다.
일부 호스트에서 제공하는 매우 유사한 서비스는 사용자의 터미널에 메시지를 전달하는 것입니다(사용자가 호스트에서 활성화되어 있는 경우).
```
사용자의 메일박스에 대한 배달은
**메일링**이라고하며, 사용자 터미널로의 배달은 **보내기**라고 합니다.
많은 호스트에서 전송 구현은 메일링 구현과 거의 동일하기 때문에 이 두 기능은 SMTP에 결합됩니다.
그러나, 전송 명령은 요구되는 최소 구현에 포함되지 않습니다(4.5.1절 참조).
사용자는 터미널에 메시지 쓰기를 제어할 수 있어야 합니다. 대부분의 호스트는 사용자가 그러한 메시지를 받아들이거나 거부할 수 있도록 허용합니다.


> 다음 세 가지 명령은 전송 옵션을 지원하기 위해 정의됩니다.
>
>이들은 MAIL 명령 대신 메일 트랜잭션에서 사용되며 receiver-SMTP에 이 트랜잭션의 특수 의미를 알려줍니다.

1. `SEND <SP> FROM:<reverse-path> <CRLF>`
SEND 명령을 사용하려면 메일 데이터가 사용자의 터미널로 전달되어야합니다.
사용자가 호스트에서 활성 상태가 아니거나 터미널 메시지를 수락하지 않으면 450 응답이 RCPT 명령으로 반환될 수 있습니다.
메시지가 터미널에 전달되면 메일 트랜잭션이 성공합니다.

2. `SOML <SP> FROM:<reverse-path> <CRLF>`
Send Or MaiL 명령을 사용하려면 사용자가 호스트에서 활성 상태이고 터미널 메시지를 승인하는 경우 메일 데이터가 사용자의 터미널로 전달 되어야 합니다.
사용자가 활성 상태가 아니거나 터미널 메시지를 수락하지 않으면 메일 데이터가 사용자의 메일박스에 입력됩니다.
메시지가 터미널 또는 메일박스에 전달되면 메일 트랜잭션이 성공합니다.

3. `SAML <SP> FROM:<reverse-path> <CRLF>`
Send And MaiL 명령을 사용하려면 사용자가 호스트에서 활성 상태이고 터미널 메시지를 수락하는 경우 메일 데이터가 사용자의 터미널로 전달 되어야 합니다.
어떤 경우에도 메일 데이터는 사용자의 메일박스에 입력됩니다. 메시지가 메일박스로 배달되면 메일 트랜잭션이 성공한 것입니다.
이 명령에는 MAIL 명령에 사용되는 것과 동일한 응답이 사용됩니다.

---

## 3.5. Opening And closing

> 전송 채널이 개방될 때, 호스트들이 그들이 생각하는 호스트들과 통신하고 있는지 확인하기 위한 교환이 있습니다.
> 다음 두 가지 명령은 전송 채널 개폐에 사용됩니다.

1. `HELO <SP> <domain> <CRLF>`
2. `QUIT <CRLF>`
HELO 명령에서 명령을 보내는 호스트는 자신을 식별합니다.
그 명령은 "Hi, I'm \<domain>"이라고 말하는 것으로 해석될 수 있습니다.

* [예제5]

```
R: 220 BBN-UNIX.ARPA Simple Mail Transfer Service Ready
S: HELO USC-ISIF.ARPA
R: 250 BBN-UNIX.ARPA
```

* [예제6]

```
S: QUIT
R: 221 BBN-UNIX.ARPA Service closing transmission channel
```

---

## 3.6. RELAYING

forward-path는 **@ONE, @TWO:JOE@THREE**형식의 소스 경로일 수 있습니다. 여기서 ONE, TWO 및 THREE는 호스트입니다.
이 양식은 주소와 경로의 구별을 강조하기 위해 사용됩니다. 메일박스는 절대 주소이고, 경로는 그곳에 가는 방법에 대한 정보입니다. 이 두 개념은 혼동되어서는 안 됩니다.
메시지가 하나의 서버-SMTP에서 다른 서버로 릴레이됨에 따라 forward-path가 reverse-path로 이동됩니다.
reverse-path는 역 소스 경로(즉, 메시지의 현재 위치에서 메시지의 발신자에게 이르는 소스 경로)입니다.
서버-SMTP가 forward-path에서 식별자를 삭제하고 reverse-path에 삽입할 때, 서로 다른 환경에서 서버-SMTP가 서로 다른 이름으로 알려진 경우, 메일이 발신된 환경이 아니라, 송신하고 있는 환경에서 알려진 이름을 사용해야 합니다.
메시지가 SMTP에 도달할 때, forward-path의 제 1 요소가 SMTP의 식별자가 아닌 경우, 요소는 forward-path에서 삭제되지 않고 메시지를 전송할 다음 SMTP를 결정하는 데 사용됩니다. 그 외의 경우엔 SMTP는 reverse-path에 자신의 식별자를 추가합니다.
소스 라우팅을 사용하여 receiver-SMTP는 다른 서버-SMTP로 중계될 메일을 수신합니다.
receiver-SMTP는 로컬 사용자에 대한 메일을 수용하거나 거부하는 것과 같은 방식으로 메일을 릴레이하는 작업을 수락하거나 거부할 수 있습니다.
receiver-SMTP는 자신의 식별자를 forward-path에서 reverse-path의 시작으로 이동시킴으로써 명령 인수를 변환합니다.
그런 다음 receiver-SMTP는 sender-SMTP가 되고, forward-path에서 다음 SMTP로의 전송 채널을 설정하고, 메일을 보냅니다.
reverse-path의 첫 번째 호스트는 SMTP 명령을 보내는 호스트여야 하며, forward-path의 첫 번째 호스트는 SMTP 명령을 받는 호스트여야 합니다.
foward-path및 reverse-path는 SMTP 명령 및 응답에 나타나지만 반드시 메시지에는 표시되지는 않습니다.
즉, 이러한 경로가 필요하지 않으며 특히 메시지 헤더 필드인  **To :**, **From :**, **CC :** 등에 나타날 필요가 없습니다.
서버-SMTP가 메일을 릴레이하는 작업을 수락하고 나중에 전달 경로가 잘못되었거나 메일이 어떤 이유로든 배달될 수 없다는 것을 알게 되면, `undeliverable mail` 알림 메시지를 배달 불가능한 메일의 발신자에게 보내야 합니다.
이 알림 메시지는 이 호스트의 서버-SMTP에서 전송해야 합니다. 물론 서버-SMTP는 알림 메시지의 문제에 대한 알림 메시지를 보내서는 안 됩니다.
오류 보고에서 루프를 방지하는 한 가지 방법은 알림 메시지의 MAIL 명령에서 null로 reverse-path를 지정하는 것입니다. 이러한 메시지가 릴레이되면 역방향 경로를 null로 남겨 둘 수 있습니다.
null reverse-path가 있는 MAIL 명령은 다음과 같이 나타납니다.
`MAIL FROM:<>`
배달 불가능한 메일의 알림 메시지는 예제7에 나와 있습니다.
이 알림은 HOSTW에서 JOE가 보낸 메시지에 대한 응답으로 HOSTX를 통해 HOSTZ로 릴레이하라는 지시와 함께 HOSTX를 통해 HOSTY로 전송됩니다.
이 예에서 볼 수있는 것은 HOSTY와 HOSTX 간의 트랜잭션으로, 알림 메시지를 반환하는 첫 번째 단계입니다.

* [예제7]

```
S: MAIL FROM:<>
R: 250 ok
S: RCPT TO:<@HOSTX.ARPA:JOE@HOSTW.ARPA>
R: 250 ok
S: DATA
R: 354 send the mail data, end with .
S: Date: 23 Oct 81 11:22:33
S: From: SMTP@HOSTY.ARPA
S: To: JOE@HOSTW.ARPA
S: Subject: Mail System Problem
S:
S: Sorry JOE, your message to SAM@HOSTZ.ARPA lost.
S: HOSTZ.ARPA said this:
S: "550 No Such User"
S: .
R: 250 ok

```

---

## 3.7. Domains

> 도메인은 ARPA 인터넷 메일 시스템에 최근에 도입된 개념입니다.
>
> 도메인의 사용은 주소 공간을 단순한 문자열 호스트 이름의 평평한 전역 공간에서 계층적으로 구조화된 전역 주소 트리로 변경합니다.
>
> 호스트 이름은 도메인 및 호스트 지정자로 대체되며, 이는 도메인 요소가 가장 특정적인 것에서 일반적인 것으로 정렬된 마침표로 분리된 문자열의 연속입니다.

예를 들어 **USC-ISIF.ARPA**, **Fred.Cambridge.UK**및 **PC7.LCS.MIT.ARPA**는 호스트 및 도메인 식별자 일 수 있습니다.
SMTP에서 도메인 이름이 사용될 땐, 공식 이름만 허용되며 별명이나 별칭의 사용은 허용되지 않습니다.

---

## 3.8. Changing roles

>TURN 명령은 전송 채널을 통해 통신하는 두 프로그램의 역할을 반대로하는 데 사용될 수 있습니다.

프로그램-A가 현재 sender-SMTP이고 TURN 명령을 송신하고 "250 OK"응답을 수신하면 프로그램-A는 receiver-SMTP가 됩니다.
프로그램-B가 현재 receiver-SMTP이고 TURN 명령을 송신하고 "250 OK"응답을 전송하면 프로그램-B는 sender-SMTP가 됩니다.
수신자가 역할 변경을 거부하려면 502 응답을 보낼 수 있습니다.
이 명령은 선택 사항입니다.
일반적으로 전송 채널이 TCP인 상황에서는 사용되지 않습니다.
그러나 전송 채널을 설정하는 비용이 높을 때 이 명령은 상당히 유용할 수 있습니다.
예를 들어, 이 명령은 공중 교환 전화 시스템을 전송 채널로 사용하여 메일 교환을 지원하는 데 유용할 수 있습니다.
특히 일부 호스트가 메일 교환을 위해 다른 호스트를 폴링하는 경우 그렇습니다.

---

# 4. The SMTP Specifications

## 4.1. SMTP Commands

### 4.1.1. Command Semantics

```
SMTP 명령은 사용자가 요청한 메일 전송 또는 메일 시스템 기능을 정의합니다.
SMTP 명령은 <CRLF>로 끝나는 문자열입니다.
명령 코드는 매개 변수가 <CRFL>뒤에 오는 경우 <SP>에 의해 종료됩니다.
메일박스의 문법은 수신자 쪽의 규칙을 따라야 합니다.
SMTP 명령은 아래에서 논의됩니다. SMTP 응답은 4.2절에서 논의됩니다.
메일 트랜잭션에는 여러 명령에 대한 인수로 전달되는 여러 데이터 개체가 포함됩니다.
reverse-path는 MAIL 명령의 인수이고, forward-path는 RCPT 명령의 인수이며, 메일 데이터는 DATA 명령의 인수입니다.
이러한 인수 또는 데이터는 트랜잭션을 완료하는 메일 데이터 표시기로 끝이 확인될 때까지 전송되고 유지되어야 합니다.
reverse-path 버퍼, forward-path 버퍼 및 메일 데이터 버퍼가 이러한 데이터 형태를 유지하기 위해 제공됩니다.
특정 명령은 특정 버퍼에 정보를 추가하거나 하나 이상의 버퍼를 지우도록 합니다.
```

1. HELLO (HELO)
이 명령은 receiver-SMTP에 대한 sender-SMTP를 식별하는 데 사용됩니다.
인수 필드에는 sender-SMTP의 호스트 이름이 포함되어 있습니다.
receiver-SMTP는 연결 인사 응답 및 이 명령에 대한 응답에서 sender-SMTP에 자신을 식별합니다.
이 명령과 명령에 대한 OK 응답은 sender-SMTP와 receiver-SMTP가 모두 초기 상태에 있다는 것을 확인시켜줍니다. 즉, 진행 중인 트랜잭션이 없고 모든 상태 테이블과 버퍼가 지워집니다.

2. MAIL (MAIL)
이 명령은 메일 데이터가 하나 이상의 메일박스로 배달되는 트랜잭션을 시작하는 데 사용됩니다.
인수로는 reverse-path를 가집니다.
reverse-path는 옵셔널 호스트 목록과 발신자 메일박스로 구성됩니다.
호스트 목록이 있으면 "reverse"소스 경로이며 메일이 목록의 각 호스트를 통해 릴레이 되었음을 나타냅니다(목록의 첫 번째 호스트가 최신 릴레이).
이 목록은 발신자에게 배달되지 않았다는 알림을 반환하는 경로로 사용됩니다.
각 릴레이 호스트가 목록의 시작에 자신을 추가하기 때문에, 메일이 온 IPCE보다는 메일을 릴레이하는 IPCE에서 알려진 이름을 사용해야 합니다.
일부 오류 보고 메시지(예: undeliverable mail notifications)에서 reverse-path는 null일 수 있습니다(예제7 참조). 
이 명령은 reverse-path 버퍼, forward-path 버퍼 및 메일 데이터 버퍼를 지웁니다. 그리고 이 명령의 reverse-path 정보를 reverse-path 버퍼에 삽입합니다.

3. RECIPIENT (RCPT)

```
이 명령은 메일 데이터의 개별 수신자를 식별하는 데 사용됩니다. 이 명령의 다중 사용으로 여러 수신자가 지정됩니다.
forward-path는 옵셔널 호스트 목록과 필요한 목적지 메일박스로 구성됩니다.
호스트 목록이 있는 경우 소스 경로이며 메일이 목록의 다음 호스트로 릴레이 되어야 함을 나타냅니다.
receiver-SMTP가 릴레이 기능을 구현하지 않은 경우, "550 unknown local user"와 동일한 응답을 사용자에게 제공 할 수 있습니다.
메일이 릴레이될 때, 릴레이 호스트는 처음의 forward-path에서 자신을 제거하고 reverse-path의 시작에 자신의 호스트를 놓아야 합니다.
메일이 궁극적인 목적지에 도달하면 receiver-SMTP는 호스트 메일 규칙에 따라 메일박스에 메일을 삽입합니다.
```

> 예를 들어, 릴레이 호스트 A에서 인수가 있는 메일 수신했을 때,
>
> FROM:<USERX@HOSTY.ARPA>
>
> TO:<@HOSTA.ARPA,@HOSTB.ARPA:USERC@HOSTD.ARPA>

인수를 통해 호스트 B에 릴레이 됩니다.

> FROM:<@HOSTA.ARPA:USERX@HOSTY.ARPA>
>
> TO:<@HOSTB.ARPA:USERC@HOSTD.ARPA>.

이 명령은 forward-path 인수를 forward-path 버퍼에 추가하게 합니다.

4. DATA (DATA)
수신자는 명령 다음의 행을 발신자의 메일 데이터로 처리합니다.
이 명령은 이 명령의 메일 데이터를 메일 데이터 버퍼에 추가합니다.
메일 데이터는 128 ASCII 문자 코드를 포함 할 수 있습니다.
메일 데이터는 마침표만을 포함하는 행, 즉 **\<CRLF>.<CRLF>** 에 의해 종료됩니다. 이것이 메일 데이터 표시의 끝 입니다.
메일 데이터 표시의 종료는 수신자가 저장한 메일 트랜잭션 정보를 처리해야 함을 요구합니다.
이 처리는 reverse-path 버퍼, forward-path 버퍼 및 메일 데이터 버퍼의 정보를 읽어들이고, 명령의 완료시에 버퍼를 제거합니다.
처리가 성공하면 수신자는 OK 응답을 보내야 합니다. 처리가 완전히 실패하면 수신자는 실패 응답을 보내야 합니다.
receiver-SMTP가 릴레이 또는 최종 배달을 위해 메시지를 수락할 때, 메일 데이터의 시작 부분에 타임 스탬프 라인을 삽입합니다.
타임 스탬프 라인은 메시지를 보낸 호스트의 ID와 메시지를 수신한 호스트의 ID, 메시지가 수신 된 날짜 및 시간을 나타냅니다.
그렇기 때문에 릴레이된 메시지에는 여러 개의 타임 스탬프 라인이 있습니다.
receiver-SMTP가 메시지의 **최종 배달**을 하면 메일 데이터의 시작 부분에 리턴 경로 행을 삽입합니다.
리턴 경로 행은 MAIL 명령의 \<reverse-path>에 있는 정보를 유지합니다.
여기서, 최종 전달은 메시지가 SMTP 환경에서 벗어난다는 것을 의미합니다.
일반적으로 이것은 목적지 사용자에게 배달되었음을 의미하지만, 경우에 따라 다른 메일 시스템에서 추가 처리되고 전송될 수 있습니다.
예를 들어 오류 응답이 메시지 보낸 사람이 아닌 특수한 오류 처리 메일박스로 배달되는 경우 반환 경로의 메일박스가 실제 보낸 사람의 메일박스와 다를 수 있습니다.
앞의 두 문장은 타임 스탬프 라인에 이어 최종 메일 데이터가 리턴 경로 라인으로 시작되었음을 의미합니다. 이 라인은 메일 데이터 헤더와 본문이 이어집니다(예제8 참조). 2
메일 데이터 표시 종료 후 처리가 부분적으로 성공한 경우 응답 및 추가 조치가 필요합니다.
이는 다수의 수신자와 메일 데이터를 수락한 후,
receiver-SMTP가 메일박스 용량 등의 문제로 일부 수신자에게 성공적으로 전달할 수 없을 경우 발생합니다.
이러한 상황에서 DATA 명령에 대한 응답은 "OK" 이어야 합니다.
그러나, receiver-SMTP는 `undeliverable mail` 알림을 메시지 발신자에게 전송해야 합니다.
그렇기 때문에, 메시지를 가지지 못한 모든 수신자에게 각각 알림을 보내거나 또는 실패한 각 수신자에 대한 별도의 알림을 전송해야 합니다(예제7 참조).
배달할 수 없는 모든 메일에 대한 알림 메시지는 SEND, SOML 또는 SAML 명령으로 처리한 결과일지라도 MAIL 명령어를 사용하여 전송됩니다.

* [예제8]

> 반송 경로 및 수신 시간 스탬프

```
Return-Path: <@GHI.ARPA,@DEF.ARPA,@ABC.ARPA:JOE@ABC.ARPA>
Received: from GHI.ARPA by JKL.ARPA ; 27 Oct 81 15:27:39 PST
Received: from DEF.ARPA by GHI.ARPA ; 27 Oct 81 15:15:13 PST
Received: from ABC.ARPA by DEF.ARPA ; 27 Oct 81 15:01:59 PST 
Date: 27 Oct 81 15:01:01 PST
From: JOE@ABC.ARPA
Subject: Improved Mailing System Installed
To: SAM@JKL.ARPA
This is to inform you that ...
```

5. SEND (SEND)
이 명령은 메일 데이터가 하나 이상의 단말기로 전달되는 메일 트랜잭션을 시작하는데 사용됩니다.
인수 필드에는 reverse-path가 있습니다.
이 명령으로 메시지가 단말기로 전달되었다면 성공입니다.
reverse-path는 호스트의 옵셔널 목록과 보낸 사람의 메일박스로 구성됩니다.
호스트 목록이 있으면 "reverse" 소스 경로이며 메일이 목록의 각 호스트를 통해 릴레이 되었음을 나타냅니다.
이 목록은 배달되지 못했다는 알림을 발신자에게 반환하기 위한 경로로 사용됩니다.
각 릴레이 호스트가 목록의 시작 부분에 자신을 추가하기 때문에 메일이 온 IPCE가 아닌 메일을 릴레이하는 IPCE에서 알려진 이름을 사용해야 합니다.
이 명령은 reverse-path, forward-path 버퍼 및 메일 데이터 버퍼를 지우고, 이 명령의 reverse-path 정보를 reverse-path 버퍼에 삽입합니다.

6. SEND OR MAIL (SOML)
이 명령은 메일 데이터가 하나 이상의 단말기 또는 메일박스에 전달되는 메일 트랜잭션을 시작하는데 사용됩니다.
각 수신자에 대해 메일 데이터는 수신자가 호스트에서 활성 상태인 경우 수신자의 터미널로 배달되며, 그렇지 않으면 수신자의 메일박스로 배달됩니다.
인수 필드에는 reverse-path가 있습니다.
이 명령은 메시지가 단말기 또는 메일박스에 전달되면 성공입니다.
reverse-path는 호스트의 옵셔널 목록과 보낸 사람의 메일박스로 구성됩니다.
호스트 목록이 있으면 "reverse" 소스 경로이며 메일이 목록의 각 호스트를 통해 릴레이 되었음을 나타냅니다.
이 목록은 배달되지 못했다는 알림을 발신자에게 반환하기 위한 경로로 사용됩니다.
각 릴레이 호스트가 목록의 시작 부분에 자신을 추가하기 때문에 메일이 온 IPCE가 아닌 메일을 릴레이하는 IPCE에서 알려진 이름을 사용해야 합니다.
이 명령은 reverse-path, forward-path 버퍼 및 메일 데이터 버퍼를 지우고, 이 명령의 reverse-path 정보를 reverse-path 버퍼에 삽입합니다.

7. SEND AND MAIL (SAML)
이 명령은 메일 데이터가 하나 이상의 단말기 및 메일박스에 전달되는 메일 트랜잭션을 시작하는데 사용됩니다.
각 수신자에 대해 메일 데이터는 수신자가 호스트에서 활성 상태인 경우 수신자의 터미널로 배달되고, 모든 수신자의 메일박스로도 배달됩니다.
인수 필드에는 reverse-path가 있습니다.
reverse-path는 호스트의 옵셔널 목록과 보낸 사람의 메일박스로 구성됩니다.
호스트 목록이 있으면 "reverse" 소스 경로이며 메일이 목록의 각 호스트를 통해 릴레이 되었음을 나타냅니다.
이 목록은 배달되지 못했다는 알림을 발신자에게 반환하기 위한 경로로 사용됩니다.
각 릴레이 호스트가 목록의 시작 부분에 자신을 추가하기 때문에 메일이 온 IPCE가 아닌 메일을 릴레이하는 IPCE에서 알려진 이름을 사용해야 합니다.
*이 명령은 reverse-path, forward-path 버퍼 및 메일 데이터 버퍼를 지우고, 이 명령의 reverse-path 정보를 reverse-path 버퍼에 삽입합니다.

8. RESET (RSET)
이 명령은 현재 메일 트랜잭션을 중단하도록 지정합니다. 저장된 발신자, 수신자 및 메일 데이터를 폐기해야 하며 모든 버퍼 및 상태 테이블이 지워집니다.수신자는 "OK" 응답을 보내야 합니다.

9. VERIFY (VRFY)
이 명령은 인수가 사용자를 식별하는지 확인하도록 수신자에 요청합니다.
사용자 이름인 경우, 사용자 이름과 완전히 지정된 메일박스가 반환됩니다.
이 명령은 reverse-path 버퍼, forward-path 버퍼 또는 메일 데이터 버퍼에 영향을 미치지 않습니다.

10. EXPAND (EXPN)
이 명령은 인수가 메일링 목록을 식별하는지 확인하고, 그렇다면 해당 목록을 반환하도록 수신자에게 요청합니다.
사용자의 전체 이름과 메일박스들이 응답으로 반환됩니다.
이 명령은 reverse-path 버퍼, forward-path 버퍼 또는 메일 데이터 버퍼에 영향을 미치지 않습니다.

11. HELP (HELP)
이 명령은 수신자가 HELP 명령의 발신자에게 유용한 정보를 보내도록합니다.
명령은 인수(임의의 명령 이름)를 사용하여 구체적인 정보를 응답으로 반환 할 수 있습니다.
이 명령은 reverse-path 버퍼, forward-path 버퍼 또는 메일 데이터 버퍼에 영향을 미치지 않습니다.

12. NOOP (NOOP)
이 명령은 매개 변수 또는 이전에 입력한 명령에 영향을 미치지 않습니다.
수신자가 "OK" 응답을 보내는 것 외에는 어떤 조치도 지정하지 않습니다.
이 명령은 reverse-path 버퍼, forward-path 버퍼 또는 메일 데이터 버퍼에 영향을 미치지 않습니다.

13. QUIT (QUIT)
이 명령은 수신자가 "OK" 응답을 보낸 다음 전송 채널을 닫게 합니다.
수신자는 QUIT 명령을 수신한 뒤, 응답 할 때까지 설령 오류가 있다 하더라도 전송 채널을 닫지 말아야 합니다.
발신자는 QUIT 명령을 보내고 응답을 받을 때까지 설령 오류가 있다 하더라도 전송 채널을 닫지 말아야 합니다.
연결이 조기에 종료되면 수신기는 RSET 명령이 수신된 것처럼 동작해야 합니다.
발신자는 명령 또는 진행중인 트랜잭션이 일시적인 오류를 수신 한 것처럼 작동해야합니다.

14. TURN (TURN)
이 명령은 수신자가 확인 응답을 보낸 후 sender-SMTP의 역할을 수행하거나, 거부 응답을 보내고 receiver-SMTP의 역할을 유지하도록 지정합니다.
프로그램A가 현재 sender-SMTP이고 TURN 명령을 송신하고 OK 응답을 수신하면 프로그램A는 receiver-SMTP가 됩니다.
프로그램A는 전송 채널이 방금 열린 것처럼 초기 상태에 있으며, 서비스 준비 메시지를 보냅니다.
프로그램B가 현재 receiver-SMTP이고 TURN 명령을 수신하고 OK 응답을 전송하면 프로그램B는 sender-SMTP가 됩니다.
프로그램B는 전송 채널이 방금 열린 것처럼 초기 상태에 있으며, 서비스 준비 인사말을 받을 것입니다.
역할 변경을 거부하려면 수신자가 502 응답을 보낼 수 있습니다.

이러한 명령을 사용할 수 있는 순서에는 제한이 있습니다.
세션의 첫 번째 명령은 HELO 명령이어야 합니다.
HELO 명령은 세션 후반에도 사용될 수 있습니다.
HELO 명령 인수가 허용되지 않으면 501 실패 응답이 반환되고 receiver-SMTP는 동일한 상태를 유지해야 합니다.
NOOP, HELP, EXPN 및 VRFY 명령은 세션 중에 언제든지 사용할 수 있습니다.
MAIL, SEND, SOML 또는 SAML 명령은 메일 트랜잭션을 시작합니다.
메일 트랜잭션이 시작되면 트랜잭션 시작 명령 중 하나, 하나 이상의 RCPT 명령 및 DATA 명령이 순서대로 구성됩니다.
RSET 명령으로 메일 트랜잭션이 중단 될 수 있습니다. 세션에 0 개 이상의 트랜잭션이 있을 수 있습니다.
트랜잭션 시작 명령 인수가 허용되지 않으면 501 실패 응답을 반환해야하며 receiver-SMTP는 동일한 상태를 유지해야 합니다.
트랜잭션의 명령이 작동하지 않는 경우 503 실패 응답을 반환해야하며 receiver-SMTP는 동일한 상태를 유지해야 합니다.
세션의 마지막 명령은 QUIT 명령이어야 합니다. 세션의 다른 순간에는 QUIT 명령을 사용할 수 없습니다.

---

### 4.1.2. Command Syntax

> 명령은 명령 코드와 인수 필드로 구성됩니다.
>
> 명령 코드는 네 개의 알파벳 문자입니다. 대문자와 소문자는 동일하게 취급됩니다.
>
> 따라서 다음 중 어느 하나가 메일 명령을 나타낼 수 있습니다.
>
> MAIL    Mail    mail    MaIl    mAIl
>
> 이것은 또한 forward-path에 대한 "TO"또는 "to"와 같은 매개 변수 값을 나타내는 모든 심볼에도 적용됩니다.
>
> 명령 코드와 인수 필드는 하나 이상의 공백으로 구분됩니다.
>
> 이러한 대소문자 규칙은 forward-path와 reverse-path에서는 중요합니다. 특히 일부 호스트에서는 사용자 "smith"가 사용자 "Smith"와 다릅니다.
>
> 인수 필드는 <CRFL>로 끝나는 문자열로 구성됩니다. 수신자는 이 문자가 수신될 때까지 아무런 조치도 취하지 않습니다.
>
> 대괄호는 선택적 인수 필드를 나타냅니다. 이 옵션을 사용하지 않으면 적절한 기본값이 사용됩니다.

* [SMTP 명령어 예]

```
HELO <SP> <domain> <CRLF>
MAIL <SP> FROM:<reverse-path> <CRLF>
RCPT <SP> TO:<forward-path> <CRLF>
DATA <CRLF>
RSET <CRLF>
SEND <SP> FROM:<reverse-path> <CRLF>
SOML <SP> FROM:<reverse-path> <CRLF>
SAML <SP> FROM:<reverse-path> <CRLF>
VRFY <SP> <string> <CRLF>
EXPN <SP> <string> <CRLF>
HELP [<SP> <string>] <CRLF>
NOOP <CRLF>
QUIT <CRLF>
TURN <CRLF>
```

> 위의 인수 필드(적용 가능한 경우 BNF 표기법을 사용)의 구문은 아래에 나와 있습니다. "..." 표기법은 필드가 하나 이상 반복될 수 있음을 나타냅니다.

```
<reverse-path> ::= <path>
<forward-path> ::= <path>
<path> ::= "<" [ <a-d-l> ":" ] <mailbox> ">"
<a-d-l> ::= <at-domain> | <at-domain> "," <a-d-l>
<at-domain> ::= "@" <domain>
<domain> ::= <element> | <element> "." <domain>
<element> ::= <name> | "#" <number> | "[" <dotnum> "]"
<mailbox> ::= <local-part> "@" <domain>
<local-part> ::= <dot-string> | <quoted-string>
<name> ::= <a> <ldh-str> <let-dig>
<ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
<let-dig> ::= <a> | <d>
<let-dig-hyp> ::= <a> | <d> | "-"
<dot-string> ::= <string> | <string> "." <dot-string>
<string> ::= <char> | <char> <string>
<quoted-string> ::= """ <qtext> """
<qtext> ::= "\" <x> | "\" <x> <qtext> | <q> | <q> <qtext>
<char> ::= <c> | "\" <x>
<dotnum> ::= <snum> "." <snum> "." <snum> "." <snum>
<number> ::= <d> | <d> <number>
<CRLF> ::= <CR> <LF>
<CR> ::= 캐리지 리턴 문자(ASCII 코드 13)
<LF> ::=라인 피드 문자(ASCII 코드 10)
<SP> ::= 공백 문자(ASCII 코드 32)
<snum> : := 1자리, 2자리 또는 3자리 십진수를 나타내는 0 ~ 255 범위의 정수 값 중 하나
<a> ::= 52자의 알파벳 A ~ Z, a ~ z 중 하나
<c> ::= 128개의 ASCII 문자 중 하나, 어떤 문자도 포함하지 않음 <special> 또는 <SP>
<d> ::= 0부터 9까지의 10진수 중 하나
<q> ::= <CR>을 제외한 128개의 ASCII 문자 중 하나, <LF>,  인용문(") 또는 백슬래시(\)
<x> ::= 128개의 ASCII 문자 중 하나(예외 없음)
<special> : : := "<" | ">" | "(" | ")" | "[" | "]" | "\" | "." | "," | ";" | ":" | "@"  """ | 통제 문자(ASCII 코드 0 ~ 31 및 127 포함)
```

백슬래시(backslash, "\")는 인용문자로, 문자 그대로(정상적인 해석 대신) 다음 문자를 사용함을 나타내는 데 사용됩니다.
예를 들어, "Joe\,Smith"는 쉼표를 필드의 네 번째 문자로 하는 9자의 필드를 나타내는 데 사용될 수 있습니다.
호스트는 일반적으로 각 호스트의 주소로 변환되는 이름으로 알려져 있습니다. 도메인의 이름 요소는 공식적인 이름이며 닉네임이나 별칭은 사용할 수 없습니다.
때때로 호스트는 변환 기능에 알려지지 않고 통신이 차단됩니다. 그렇기 때문에 호스트 "이름"에도 두 개의 숫자 양식이 허용됩니다.
한 가지 형태는 파운드 기호 "#"로 접두사된 소수 정수로, 숫자가 호스트의 주소임을 나타냅니다.
또 다른 형태는 점으로 구분되고 괄호로 둘러싸인 4개의 작은 소수 정수, 예를 들어 "\[123.255.37.2]"로, 4개의 8 비트 필드에서 32 비트 ARPA 인터넷 주소를 나타냅니다.

타임 스탬프 라인과 리턴 경로 라인은 공식적으로 다음과 같이 정의됩니다:

```
<return-path-line> ::= "Return-Path:" <SP><reverse-path><CRLF>
<time-stamp-line> ::= "Received:" <SP> <stamp> <CRLF>
<stamp> ::= <from-domain> <by-domain> <opt-info> ";"
<daytime>
<from-domain> ::= "FROM" <SP> <domain> <SP>
<by-domain> ::= "BY" <SP> <domain> <SP>
<opt-info> ::= [<via>] [<with>] [<id>] [<for>]
<via> ::= "VIA" <SP> <link> <SP>
<with> ::= "WITH" <SP> <protocol> <SP>
<id> ::= "ID" <SP> <string> <SP>
<for> ::= "FOR" <SP> <path> <SP>
<link> ::= 링크의 표준 이름은 네트워크 정보 센터에 등록되어 있습니다.
<protocol> ::= 프로토콜의 표준 이름은 네트워크 정보 센터에 등록되어 있습니다.
<daytime> ::= <SP> <date> <SP> <time>
<date> ::= <dd> <SP> <mon> <SP> <yy>
<time> ::= <hh> ":" <mm> ":" <ss> <SP> <zone>
<dd> ::= 1-31인 월의 정수일.
<mon> ::= "JAN" | "FEB" | "MAR" | "APR" | "MAY" | "JUN" |
"JUL" | "AUG" | "SEP" | "OCT" | "NOV" | "DEC"
<yy> ::= 00-99인 세기의 정수년.
<hh> ::= 00-24인 하루의 시간 .
<mm> ::= 00-59인 시간의 분.
<ss> ::= 00-59인 분의 초.
<zone> ::= 세계시 또는 기타 "UT" 시간대 지정자.
```

* [예제9]

> 반환 경로 예제

```
Return-Path: <@CHARLIE.ARPA,@BAKER.ARPA:JOE@ABLE.ARPA>
```

* [예제10]

> 타임 스탬프 라인 예제

```
Received: FROM ABC.ARPA BY XYZ.ARPA ; 22 OCT 81 09:23:59 PDT
Received: from ABC.ARPA by XYZ.ARPA via TELENET with X25
id M12345 for Smith@PDQ.ARPA ; 22 OCT 81 09:23:59 PDT
```

---

## 4.2. SMTP Replies

```
SMTP 명령에 대한 응답은 메일 전송 과정에서 요청 및 액션의 동기화를 보장하고 sender-SMTP가 항상 receiver-SMTP의 상태를 알고 있음을 보장하기 위해 고안되었습니다.
모든 명령은 정확히 하나의 응답을 발생시켜야 합니다.
명령 응답 시퀀스의 세부 사항은 5.3절 Sequencing 과 5.4절 State Diagrams에 명시되어 있습니다.
```

> SMTP 응답은 3자리 숫자와 텍스트로 구성됩니다. 이 숫자는 다음에 어떤 상태로 들어갈 것인지를 결정하기 위해서 사용되며, 텍스트는 사용자를 위한 것입니다.
>
> 세 자리 숫자에는 sender-SMTP가 텍스트를 검사할 필요가 없는 충분한 인코딩된 정보가 포함되어 있으며, 적절한 경우 텍스트를 폐기하거나 사용자에게 전달할 수 있습니다.
>
> 특히, 텍스트는 수신자에 따라 다르고 상황에 따라 달라질 수 있으므로 각 응답 코드에 따라 다양한 텍스트가 있을 수 있습니다.
>
> 응답 코드 이론에 대한 설명은 부록 E에 나와 있습니다.
>
> 공식적으로 응답은 3 자리 코드, <SP>, 한 줄의 텍스트 및 <CRLF> 또는 여러 줄로 된 응답으로 정의됩니다.
>
> EXPN 및 HELP 명령만 정상적인 상황에서 다중 응답을 초래할 것으로 예상되지만, 모든 명령에 대해 다중 응답이 허용됩니다.

---

### 4.2.1. Reply codes by function groups

```
500 Syntax error, command unrecognized [This may include errors such as command line too long]
501 Syntax error in parameters or arguments
502 Command not implemented
503 Bad sequence of commands
504 Command parameter not implemented
211 System status, or system help reply
214 Help message [Information on how to use the receiver or the meaning of a particular non-standard command; this reply is useful only to the human user]
220 <domain> Service ready
221 <domain> Service closing transmission channel
421 <domain> Service not available, closing transmission channel [This may be a reply to any command if the service knows it must shut down]
250 Requested mail action okay, completed
251 User not local; will forward to <forward-path>
450 Requested mail action not taken: mailbox unavailable [e.g., mailbox busy]
550 Requested action not taken: mailbox unavailable [e.g., mailbox not found, no access]
451 Requested action aborted: error in processing
551 User not local; please try <forward-path>
452 Requested action not taken: insufficient system storage
552 Requested mail action aborted: exceeded storage allocation
553 Requested action not taken: mailbox name not allowed [e.g., mailbox syntax incorrect]
354 Start mail input; end with <CRLF>.<CRLF>
554 Transaction failed
```

---

### 4.2.2. Numeric order list of reply codes

```
211 System status, or system help reply
214 Help message [Information on how to use the receiver or the meaning of a particular non-standard command; this reply is useful only to the human user]
220 <domain> Service ready
221 <domain> Service closing transmission channel
250 Requested mail action okay, completed
251 User not local; will forward to <forward-path>
354 Start mail input; end with <CRLF>.<CRLF>
421 <domain> Service not available, closing transmission channel [This may be a reply to any command if the service knows it must shut down]
450 Requested mail action not taken: mailbox unavailable [e.g., mailbox busy]
451 Requested action aborted: local error in processing
452 Requested action not taken: insufficient system storage
500 Syntax error, command unrecognized [This may include errors such as command line too long]
501 Syntax error in parameters or arguments
502 Command not implemented
503 Bad sequence of commands
504 Command parameter not implemented
550 Requested action not taken: mailbox unavailable [e.g., mailbox not found, no access]
551 User not local; please try <forward-path>
552 Requested mail action aborted: exceeded storage allocation
553 Requested action not taken: mailbox name not allowed [e.g., mailbox syntax incorrect]
554 Transaction failed
```

---

## 4.3. Sequencing of commands and replies

```
발신자와 수신자 사이의 통신은 발신자에 의해 제어되고, 교대로 이루어지는 대화입니다. 이와 같이 발신자는 명령을 내리고 수신자는 명령에 대해 응답합니다. 발신자는 추가 명령을 전송하기 전에 이전의 응답을 기다려야 합니다.
중요한 응답 중 하나는 연결 인사말입니다. 수신자는 연결이 완료되면 "220 Service ready"응답을 보냅니다. 발신자는 명령을 보내기 전에 이 인사말 메시지를 기다려야 합니다.
모든 인사말에는 응답 코드 다음에 오는 첫 단어로 서버 호스트의 공식 이름이 있습니다.
```

* [예] `220 <SP> USC-ISIF.ARPA <SP> Service ready <CRLF>`

> 아래 예시에는 각 명령에 대한 대체 성공 및 실패 응답이 나열되어 있습니다.
>
> 이것들은 엄격하게 지켜져야 합니다. 수신자는 응답에서 텍스트를 대체할 수 있지만, 코드 번호와 특정 명령 응답 시퀀스에 의해 암시되는 의미와 행동은 변경될 수 없습니다.
>
>  명령은 가능한 응답과 함께 나열됩니다. 가능한 응답 전에 사용 된 접두사는 예비(SMTP에서 사용되지 않음)의 경우 "P", 중간의 경우 "I", 성공의 경우 "S", 실패의 경우 "F", 오류의 경우 "E"입니다.
>
> SMTP-receiver가 종료해야 한다는 것을 알면 421 응답(service not available, closing transmission channel)은 모든 명령에 주어질 수 있습니다.
>
> 이 목록은 4.4 절의 상태 다이어그램의 기초를 형성합니다.

```
CONNECTION ESTABLISHMENT
S: 220
F: 421
```
```
HELO
S: 250
E: 500, 501, 504, 421
```
```
MAIL
S: 250
F: 552, 451, 452
E: 500, 501, 421
```
```
RCPT
S: 250, 251
F: 550, 551, 552, 553, 450, 451, 452
E: 500, 501, 503, 421
```
```
DATA
I: 354 -> data -> S: 250
F: 552, 554, 451, 452
F: 451, 554
E: 500, 501, 503, 421
```
```
RSET
S: 250
E: 500, 501, 504, 421
```
```
SEND
S: 250
F: 552, 451, 452
E: 500, 501, 502, 421
```
```
SOML
S: 250
F: 552, 451, 452
E: 500, 501, 502, 421
```
```
SAML
S: 250
F: 552, 451, 452
E: 500, 501, 502, 421
```
```
VRFY
S: 250, 251
F: 550, 551, 553
E: 500, 501, 502, 504, 421
```
```
EXPN
S: 250
F: 550
E: 500, 501, 502, 504, 421
```
```
HELP
S: 211, 214
E: 500, 501, 502, 504, 421
```
```
NOOP
S: 250
E: 500, 421
```
```
QUIT
S: 221
E: 500
```
```
TURN
S: 250
F: 502
E: 500, 503
```

---

## 4.4. State Diagrams

```
다음은 간단한 SMTP 구현을위한 상태 다이어그램입니다. 응답 코드의 첫 번째 숫자만 사용됩니다. SMTP 명령 그룹마다 하나의 상태 다이어그램이 있습니다.
명령 그룹화는 각 명령에 대한 모델을 구성한 다음 구조적으로 동일한 모델과 함께 명령을 수집하여 그룹화를 결정하였습니다.
각 명령에 대해 "성공"(S), "실패"(F) 및 "오류"(E)의 세 가지 가능한 결과가 있습니다. 아래의 상태 다이어그램에서 "시작"에 기호 B를 사용하고 "응답 대기"에 기호 W를 사용합니다.
```

![2020-03-17-2](https://github.com/Leeheejin/leeheejin.github.io/blob/master/images/2020-03-17/2.png?raw=true) 
대부분의 SMTP 명령을 나타내는 다이어그램 :

> 이 다이어그램이 모델링하는 명령들:
>
> HELO, MAIL, RCPT, RSET, SEND, SOML, SAML, VRFY, EXPN, HELP, NOOP, QUIT, TURN

![2020-03-17-3](https://github.com/Leeheejin/leeheejin.github.io/blob/master/images/2020-03-17/3.png?raw=true) 
DATA 명령을 모델링하는 보다 복잡한 다이어그램:

> 여기에서 "DATA"는 발신자로부터 수신자에게 전송된 일련의 라인이며 마지막 라인이 전송 될 때까지 응답을 반환하지 않습니다.

## 4.5. Details

### 4.5.1. Minimum Implementation

> SMTP를 실행 가능하게 하려면 모든 수신자에 대해 다음 최소 구현이 필요합니다.


* COMMANDS

```
HELO
MAIL
RCPT
DATA
RSET
NOOP
QUIT
```

---

### 4.5.2. Transparency

데이터 투명성에 대한 조항이 없는 경우 문자열 **<CRLF>.<CRLF>**는 메일 텍스트를 종료시키고 사용자가 발송할 수 없게 합니다.
일반적으로 사용자들은 그러한 **금지된** 시퀀스를 알지 못합니다.
사용자가 작성한 모든 텍스트를 투명하게 전송할 수 있도록 다음 절차를 사용합니다.

>한 줄의 메일 텍스트를 보내기 전에 sender-SMTP는 줄의 첫 문자를 확인합니다. 마침표인 경우 줄의 시작 부분에 추가 마침표가 삽입됩니다.
>
> 메일 텍스트 라인이 receiver-SMTP에 의해 수신되면 라인을 확인합니다.  하나의 마침표로 줄이 구성되어 있으면 메일의 끝입니다. 첫 번째 문자가 마침표이고 줄에 다른 문자가 있으면 첫 번째 문자가 삭제됩니다.
>
> 메일 데이터에는 128개의 ASCII 문자가 포함될 수 있습니다.
>
> 모든 문자는 형식 이펙터 및 기타 제어 문자를 포함하여 수신자의 메일박스로 전달됩니다.
>
> 전송 서비스가 8-비트 바이트(옥텟) 전송 채널을 제공 할 때 각각의 7-비트 문자는 오른쪽으로 정렬되고, 상위 비트는 0으로 지워져 전송됩니다.
>
> 일부 시스템에서는 데이터를 수신하고 저장하는 대로 변환해야 할 수도 있습니다. 
>
> 이는 ASCII와 다른 문자 세트를 로컬 문자 세트로 사용하거나 문자열이 아닌 레코드에 데이터를 저장하는 호스트에 필요할 수 있습니다.
>
> 이러한 변환이 필요한 경우, 특히 변환중인 메일에 이러한 변환이 적용되는 경우에 이를 되돌릴 수 있어야 합니다.

---

### 4.5.3. Sizes

최소,최대 크기를 필요로 하는 여러 객체가 있습니다.
즉, 모든 구현은 이러한 크기 이상의 오브젝트를 수신 할 수 있어야 하지만 이러한 크기보다 큰 오브젝트를 보내면 안됩니다.
**가능한 한 최대한의 구현 기술을 사용하여 이러한 오브젝트의 길이에 제한을 두지 않아야 합니다.**

```
user
The maximum total length of a user name is 64 characters.
사용자 이름의 최대 총 길이는 64자 입니다.
```

```
domain
The maximum total length of a domain name or number is 64
characters.
도메인 이름 또는 숫자의 최대 총 길이는 64자입니다.
```

```
path
The maximum total length of a reverse-path or forward-path is 256 characters (including the punctuation and element separators).
reverse-path 또는 forward-path의 최대 총 길이는 256 자 (문장 부호 및 요소 구분 기호 포함)입니다.
```

```
command line
The maximum total length of a command line including the command word and the <CRLF> is 512 characters.
명령어 및 명령어를 포함하는 행의 최대 총 길이는 512자 입니다.
```

```
reply line
The maximum total length of a reply line including the reply code and the <CRLF> is 512 characters.
응답 코드를 포함하는 행의 최대 총 길이는 512자 입니다.
```

```
text line
The maximum total length of a text line including the <CRLF> is 1000 characters (but not counting the leading dot duplicated for transparency).
<CRLF>를 포함하여 텍스트 행의 최대 총 길이는 1000 자 입니다(단, 투명성을 위해 중복 된 선행 마침표는 포함하지 않음).
```

```
recipients buffer
The maximum total number of recipients that must be buffered is 100 recipients.
버퍼링 해야하는 최대 총 수신자 수는 100 명입니다.
```

**가능한 한 최대한의 구현 기술을 사용하여 이러한 객체의 길이에 제한을 두지 않아야 합니다.**

```
이러한 한계를 초과하여 발생한 오류는 다음과 같은 코드를 사용하여 응답할 수 있습니다.
500 Line too long.
501 Path too long
552 Too many recipients.
552 Too much mail data.
```

---

# Appendix A

* TCP Transport service

    * 전송 제어 프로토콜은 ARPA 인터넷 및 인터넷 작업 프로토콜에 대한 미국 DoD 표준을 따르는 모든 네트워크에서 사용됩니다. 3

* Connection Establishment

    * SMTP 전송 채널은 발신자 프로세스 포트 U와 수신자 프로세스 포트 L 사이에 설정된 TCP 연결입니다.
    * 이 단일 전이중 연결은 전송 채널로 사용됩니다.
    * 이 프로토콜에는 서비스 포트 25(31 옥탈), 즉 L=25가 할당됩니다.
    
* Data Transfer
    * TCP 연결은 8비트 바이트의 전송을 지원합니다.
    * SMTP 데이터는 7비트 ASCII 문자입니다. 각 문자는 8 비트 바이트로 전송되며 고차 비트는 0으로 전송됩니다.

---

# Appendix B

* NCP Transport service
    * ARPANET 호스트 to 호스트 프로토콜(네트워크 제어 프로그램에 의해 구현됨)은 ARPANET에서 사용될 수 있습니다. 4

* Connection Establishment
    * SMTP 전송 채널은 송신자 프로세스 소켓 U와 수신자 프로세스 소켓 L 사이에서 NCP를 통해 설정됩니다.
    * 초기 연결 프로토콜이 단순 연결 뒤에 이어집니다. 5
    * 이 한 쌍의 연결은 전송 채널로 사용됩니다.
    * 이 프로토콜에는 접근 소켓 25(31 옥탈), 즉 L=25가 할당됩니다.

* Data Transfer
    * NCP 연결은 8비트 바이트의 전송을 지원합니다.
    * SMTP 데이터는 7비트 ASCII 문자입니다. 각 문자는 8 비트 바이트로 전송되며 고차 비트는 0으로 전송됩니다.

---

# Appendix C

* NITS
    * 네트워크 독립 전송 서비스를 이용합니다. 6

* Connection Establishment
    * SMTP 전송 채널은 송신자 프로세스와 수신자 프로세스 사이의 NITS를 통해 설정됩니다.
    * 발신자 프로세스는 초기의 CONECT를 실행시키고, 대기 수신 프로세스는 초기의 ACCEPT를 실행시킵니다.
* Data Transfer
    * NITS 연결은 8비트 바이트의 전송을 지원합니다.
    * SMTP 데이터는 7비트 ASCII 문자입니다. 각 문자는 8 비트 바이트로 전송되며 고차 비트는 0으로 전송됩니다.

---

# Appendix D

* X.25 Transport service
    * 퍼블릭 데이터 네트워크(Public Data Networks)가 제공 한대로 X.25 서비스를 직접 사용하는 것이 가능할 수도 있지만, TCP와 같은 안정적인 END-TO-END 프로토콜을 X.25 연결 위에 사용하는 것이 좋습니다. 7

---

# Appendix E

* Theory of Reply Codes
* 응답의 숫자코드인 세 숫자는 각각 특별한 의미를 갖습니다.
* 첫 번째 숫자는 응답이 좋은지, 나쁜지, 불완전 한지를 나타냅니다. 
* sender-SMTP는 이 첫 번째 자릿수를 검사하면 하면 다음 동작(proceed as planned, redo, retrench, etc.)을 결정할 수 있습니다.
* 어떤 오류가 발생했는지 대략 알고자 하는 sender-SMTP는 두 번째 숫자를 확인하거나, 완벽한 오류의 정보를 알기 위해 세 번째 숫자를 확인할 수 있습니다.
* 숫자코드의 첫 번째 숫자는 5개의 값중 하나를 가질 수 있습니다.

    > 1yz : 긍정적 예비 응답
    * 명령은 수락되었지만, 요청된 조치는 응답의 정보가 확인될 때까지 보류되고 있습니다.
    * sender-SMTP는 작업을 계속할지 중단할지 여부를 지정하는 다른 명령을 보내야 합니다.

    > 2yz : 긍정적 완료 응답
    * 요청이 성공적으로 완료되었습니다. 새로운 요청이 개시될 수 있습니다.

    > 3yz : 긍정적 중간 응답
    * 명령은 수락되었지만 요청된 조치는 추가 정보를 수신할 때까지 보류 중입니다.
    * sender-SMTP는이 정보를 담은 다른 명령을 보내야합니다.
    * 이 응답은 명령 순서 그룹에서 사용됩니다.
    
    > 4yz : 일시적인 부정적 완료 응답
    * 명령이 승인되지 않았고 요청된 작업이 발생하지 않았습니다.
    * 그러나 오류 조건은 일시적이며 작업을 다시 요청할 수 있습니다. 발신자는 명령 시퀀스의 시작 부분으로 돌아가야 합니다.
    * 서로 다른 두 측(발신자와 수신자)가 "일시적"이라는 의미를 해석하는 것은 합의하기가 어렵습니다.
    * 이 카테고리의 각 응답은 시간 값이 다를 수 있지만 sender-SMTP는 다시 시도하는 것이 권장됩니다.
    * 응답이 4yz 또는 5yz 카테고리에 맞는지 여부를 결정할 때, 명령 형식이나 발신자 또는 수신자의 속성 변경없이 반복 될 수있는 경우에 응답은 4yz가 될 수 있습니다.
    * (예를 들어, 명령은 동일하게 반복되고 수신기는 새로운 구현을 설정하지 않을때)

    > 5yz :  영구적인 부정적 완료 응답
    * 명령이 승인되지 않았고 요청된 작업이 발생하지 않았습니다.
    * sender-SMTP는 정확한 요청을 동일한 순서로 반복하지 않는 것이 좋습니다.
    * 어떤 "영구적인"오류 조건도 수정할 수 있으므로 사용자는 sender-SMTP가 미래에 명령 시퀀스를 다시 시작하도록 지시할 수 있습니다.
    * 두 번째 숫자는 특정 카테고리의 응답을 다룹니다.

    > x0z : 문법
    * 이러한 응답은 구문 오류, 기능 범주에 맞지 않는 구문적으로 올바른 명령, 구현되지 않거나 불필요한 명령을 가리킵니다.
    
    > x1z : 정보
    * 상태나 도움말과 같은 정보 요청에 대한 답변입니다.
    
    > x2z : 연결
    * 전송 채널을 가리키는 응답입니다.
    
    > x3z, x4z : 아직 지정되지 않음
    
    > x5z : 메일 시스템
    * 이러한 응답은 요청된 전송 또는 기타 메일 시스템 동작과 비교하여 수신자 메일 시스템의 상태를 나타냅니다.

세 번째 숫자는 두 번째 숫자로 지정된 각 카테고리에서 더 자세한 의미를 제공합니다.
각 응답 텍스트는 의무적인 것이 아니라 권장이며, 관련 명령에 따라 변경될 수도 있습니다.

반면에, 숫자 코드는 이 절의 사양을 엄격히 따라야 합니다. 
수신자 구현은 여기에 설명된 것과 약간 다른 상황에 대한 새로운 코드를 만들어서는 안 되며, 이미 정의된 코드를 채택해야 합니다.
예를 들어, 성공적인 실행으로 sender-SMTP에 새로운 정보를 제공하지 않는 NOOP와 같은 명령은 250 응답을 반환합니다.
어느 쪽에도 명령이 구현되지 않은 액션을 요청할 때 응답은 502입니다. 명령이 구현되었을 때의 응답은 504 이지만, 구현되지 않은 매개 변수를 요청할때 발생합니다.

응답 텍스트는 단일 줄보다 길 수 있습니다.
이러한 경우, sender-SMTP가 응답 읽기를 중지할 수 있는 시기를 알 수 있도록 전체 텍스트를 표시해야 합니다.
이렇게 하려면 다중 응답을 표시하는 특수 형식이 필요합니다.
여러 줄 응답의 형식을 사용하려면 마지막 줄을 제외한 모든 줄은 응답 코드로 시작하고 바로 뒤에 하이픈 "-"과 텍스트가 있어야 합니다.
마지막 줄은 응답 코드로 시작하고 바로 뒤에 **<SP>**, 선택적으로 일부 텍스트 및 **<CRLF>**가 옵니다.

* [예]

```
123-First line
123-Second line
123-234 text beginning with numbers
123 The last line
```

> sender-SMTP는 행의 시작 부분에서 응답 코드와 <SP>를 차례로 검색만 하면 됩니다.
>
> 경우에 따라 응답 "텍스트"에 발신자에게 중요한 데이터가 있습니다.
>
> 발신자는 응답으로부터 상황을 알게 될 것입니다.

---

# Appendix F

> Scenarios
>
> 이 절에서는 여러 유형의 SMTP 세션에 대한 시나리오를 제시합니다.

* A Typical SMTP Transaction Scenario
    * 이 SMTP 예는 호스트 USC-ISIF의 Smith가 호스트 BBN-UNIX의 Jones, Green 및 Brown에게 보낸 메일을 보여줍니다.
    * 여기서 우리는 호스트 USC-ISIF가 호스트 BBN-UNIX와 직접 연결되었다고 가정합니다.
    * 메일은 Jones와 Brown에게 전달됩니다. Green은 호스트 BBN-UNIX에 메일박스가 없습니다.

    ```
    R: 220 BBN-UNIX.ARPA Simple Mail Transfer Service Ready
    S: HELO USC-ISIF.ARPA
    R: 250 BBN-UNIX.ARPA
    S: MAIL FROM:<Smith@USC-ISIF.ARPA>
    R: 250 OK
    S: RCPT TO:<Jones@BBN-UNIX.ARPA>
    R: 250 OK
    S: RCPT TO:<Green@BBN-UNIX.ARPA>
    R: 550 No such user here
    S: RCPT TO:<Brown@BBN-UNIX.ARPA>
    R: 250 OK
    S: DATA
    R: 354 Start mail input; end with <CRLF>.<CRLF>
    S: Blah blah blah...
    S: ...etc. etc. etc.
    S: .
    R: 250 OK
    S: QUIT
    R: 221 BBN-UNIX.ARPA Service closing transmission channel
    ```

* Aborted SMTP Transaction Scenario
    ```
    R: 220 MIT-Multics.ARPA Simple Mail Transfer Service Ready
    S: HELO ISI-VAXA.ARPA
    R: 250 MIT-Multics.ARPA
    S: MAIL FROM:<Smith@ISI-VAXA.ARPA>
    R: 250 OK
    S: RCPT TO:<Jones@MIT-Multics.ARPA>
    R: 250 OK
    S: RCPT TO:<Green@MIT-Multics.ARPA>
    R: 550 No such user here
    S: RSET
    R: 250 OK
    S: QUIT
    R: 221 MIT-Multics.ARPA Service closing transmission channel
    ```

* Relayed Mail Scenario
    * 1단계 - 호스트를 릴레이할 소스 호스트
        ```
        R: 220 USC-ISIE.ARPA Simple Mail Transfer Service Ready
        S: HELO MIT-AI.ARPA
        R: 250 USC-ISIE.ARPA
        S: MAIL FROM:<JQP@MIT-AI.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA:Jones@BBN-VAX.ARPA>
        R: 250 OK
        S: DATA
        R: 354 Start mail input; end with <CRLF>.<CRLF>
        S: Date: 2 Nov 81 22:33:44
        S: From: John Q. Public <JQP@MIT-AI.ARPA>
        S: Subject: The Next Meeting of the Board
        S: To: Jones@BBN-Vax.ARPA
        S:
        S: Bill:
        S: The next meeting of the board of directors will be
        S: on Tuesday.
        S: John.
        S: .
        R: 250 OK
        S: QUIT
        R: 221 USC-ISIE.ARPA Service closing transmission channel
        ```
   
    * 2단계 - 대상 호스트에 릴레이 호스트
        ```
        R: 220 BBN-VAX.ARPA Simple Mail Transfer Service Ready
        S: HELO USC-ISIE.ARPA
        R: 250 BBN-VAX.ARPA
        S: MAIL FROM:<@USC-ISIE.ARPA:JQP@MIT-AI.ARPA>
        R: 250 OK
        S: RCPT TO:<Jones@BBN-VAX.ARPA>
        R: 250 OK
        S: DATA
        R: 354 Start mail input; end with <CRLF>.<CRLF>
        S: Received: from MIT-AI.ARPA by USC-ISIE.ARPA ;
        2 Nov 81 22:40:10 UT
        S: Date: 2 Nov 81 22:33:44
        S: From: John Q. Public <JQP@MIT-AI.ARPA>
        S: Subject: The Next Meeting of the Board
        S: To: Jones@BBN-Vax.ARPA
        S:
        S: Bill:
        S: The next meeting of the board of directors will be
        S: on Tuesday.
        S: John.
        S: .
        R: 250 OK
        S: QUIT
        R: 221 USC-ISIE.ARPA Service closing transmission channel
        ```
    
* Verifying and Sending Scenario
    ```
    R: 220 SU-SCORE.ARPA Simple Mail Transfer Service Ready
    S: HELO MIT-MC.ARPA
    R: 250 SU-SCORE.ARPA
    S: VRFY Crispin
    R: 250 Mark Crispin <Admin.MRC@SU-SCORE.ARPA>
    S: SEND FROM:<EAK@MIT-MC.ARPA>
    R: 250 OK
    S: RCPT TO:<Admin.MRC@SU-SCORE.ARPA>
    R: 250 OK
    S: DATA
    R: 354 Start mail input; end with <CRLF>.<CRLF>
    S: Blah blah blah...
    S: ...etc. etc. etc.
    S: .
    R: 250 OK
    S: QUIT
    R: 221 SU-SCORE.ARPA Service closing transmission channel
    ```
* Sending and Mailing Scenarios
    * 먼저 사용자의 이름이 확인된 후 사용자의 단말기로 전송시도가 이루어집니다.
    * 이 메시지가 실패하면 메시지가 사용자의 메일박스로 전달됩니다.
        ```
        R: 220 SU-SCORE.ARPA Simple Mail Transfer Service Ready
        S: HELO MIT-MC.ARPA
        R: 250 SU-SCORE.ARPA
        S: VRFY Crispin
        R: 250 Mark Crispin <Admin.MRC@SU-SCORE.ARPA>
        S: SEND FROM:<EAK@MIT-MC.ARPA>
        R: 250 OK
        S: RCPT TO:<Admin.MRC@SU-SCORE.ARPA>
        R: 450 User not active now
        S: RSET
        R: 250 OK
        S: MAIL FROM:<EAK@MIT-MC.ARPA>
        R: 250 OK
        S: RCPT TO:<Admin.MRC@SU-SCORE.ARPA>
        R: 250 OK
        S: DATA
        R: 354 Start mail input; end with <CRLF>.<CRLF>
        S: Blah blah blah...
        S: ...etc. etc. etc.
        S: .
        R: 250 OK
        S: QUIT
        R: 221 SU-SCORE.ARPA Service closing transmission channel
        ```
    
    * 이전 시나리오를 보다 효율적으로 실행합니다.
    
        ```
        R: 220 SU-SCORE.ARPA Simple Mail Transfer Service Ready
        S: HELO MIT-MC.ARPA
        R: 250 SU-SCORE.ARPA
        S: VRFY Crispin
        R: 250 Mark Crispin <Admin.MRC@SU-SCORE.ARPA>
        S: SOML FROM:<EAK@MIT-MC.ARPA>
        R: 250 OK
        S: RCPT TO:<Admin.MRC@SU-SCORE.ARPA>
        R: 250 User not active now, so will do mail.
        S: DATA
        R: 354 Start mail input; end with <CRLF>.<CRLF>
        S: Blah blah blah...
        S: ...etc. etc. etc.
        S: .
        R: 250 OK
        S: QUIT
        R: 221 SU-SCORE.ARPA Service closing transmission channel
        ```
* Mailing List Scenario
    * 먼저 두 개의 메일링 리스트 각각은 서로 다른 호스트와 별도의 세션으로 확장됩니다.
    * 그런 다음 메시지는 릴레이 호스트를 통해 두 목록에 나타나는 모든 사람에게 중복 없이 전송됩니다.

    * 1단계 - 첫 번째 목록 확장
        ```
        R: 220 MIT-AI.ARPA Simple Mail Transfer Service Ready
        S: HELO SU-SCORE.ARPA
        R: 250 MIT-AI.ARPA
        S: EXPN Example-People
        R: 250-<ABC@MIT-MC.ARPA>
        R: 250-Fred Fonebone <Fonebone@USC-ISIQ.ARPA>
        R: 250-Xenon Y. Zither <XYZ@MIT-AI.ARPA>
        R: 250-Quincy Smith <@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
        R: 250-<joe@foo-unix.ARPA>
        R: 250 <xyz@bar-unix.ARPA>
        S: QUIT
        R: 221 MIT-AI.ARPA Service closing transmission channel
        ```
    
    * 2단계 - 두 번째 목록 확장
        ```
        R: 220 MIT-MC.ARPA Simple Mail Transfer Service Ready
        S: HELO SU-SCORE.ARPA
        R: 250 MIT-MC.ARPA
        S: EXPN Interested-Parties
        R: 250-Al Calico <ABC@MIT-MC.ARPA>
        R: 250-<XYZ@MIT-AI.ARPA>
        R: 250-Quincy Smith <@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
        R: 250-<fred@BBN-UNIX.ARPA>
        R: 250 <xyz@bar-unix.ARPA>
        S: QUIT
        R: 221 MIT-MC.ARPA Service closing transmission channel
        ```
    
    * 3단계 - 릴레이 호스트를 통해 모든 사용자에게 메일 전송
        ```
        R: 220 USC-ISIE.ARPA Simple Mail Transfer Service Ready
        S: HELO SU-SCORE.ARPA
        R: 250 USC-ISIE.ARPA
        S: MAIL FROM:<Account.Person@SU-SCORE.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA:ABC@MIT-MC.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA:Fonebone@USC-ISIQA.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA:XYZ@MIT-AI.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA,@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA:joe@FOO-UNIX.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA:xyz@BAR-UNIX.ARPA>
        R: 250 OK
        S: RCPT TO:<@USC-ISIE.ARPA:fred@BBN-UNIX.ARPA>
        R: 250 OK
        S: DATA
        R: 354 Start mail input; end with <CRLF>.<CRLF>
        S: Blah blah blah...
        S: ...etc. etc. etc.
        S: .
        R: 250 OK
        S: QUIT
        R: 221 USC-ISIE.ARPA Service closing transmission channel
        ```

* Forwarding Scenarios
    * 전체
        ```
        R: 220 USC-ISIF.ARPA Simple Mail Transfer Service Ready
        S: HELO LBL-UNIX.ARPA
        R: 250 USC-ISIF.ARPA
        S: MAIL FROM:<mo@LBL-UNIX.ARPA>
        R: 250 OK
        S: RCPT TO:<fred@USC-ISIF.ARPA>
        R: 251 User not local; will forward to <Jones@USC-ISI.ARPA>
        S: DATA
        R: 354 Start mail input; end with <CRLF>.<CRLF>
        S: Blah blah blah...
        S: ...etc. etc. etc.
        S: .
        R: 250 OK
        S: QUIT
        R: 221 USC-ISIF.ARPA Service closing transmission channel
        ```
    * 1단계 - 첫 번째 호스트에서 메일박스 접근 시도
    
        ```
        R: 220 USC-ISIF.ARPA Simple Mail Transfer Service Ready
        S: HELO LBL-UNIX.ARPA
        R: 250 USC-ISIF.ARPA
        S: MAIL FROM:<mo@LBL-UNIX.ARPA>
        R: 250 OK
        S: RCPT TO:<fred@USC-ISIF.ARPA>
        R: 251 User not local; will forward to <Jones@USC-ISI.ARPA>
        S: RSET
        R: 250 OK
        S: QUIT
        R: 221 USC-ISIF.ARPA Service closing transmission channel
        ```
    
    * 2단계 - 두 번째 호스트에서 메일 배달
        ```
        R: 220 USC-ISI.ARPA Simple Mail Transfer Service Ready
        S: HELO LBL-UNIX.ARPA
        R: 250 USC-ISI.ARPA
        S: MAIL FROM:<mo@LBL-UNIX.ARPA>
        R: 250 OK
        S: RCPT TO:<Jones@USC-ISI.ARPA>
        R: OK
        S: DATA
        R: 354 Start mail input; end with <CRLF>.<CRLF>
        S: Blah blah blah...
        S: ...etc. etc. etc.
        S: .
        R: 250 OK
        S: QUIT
        R: 221 USC-ISI.ARPA Service closing transmission channel
        ```

* Too Many Recipients Scenario
    ```
    R: 220 BERKELEY.ARPA Simple Mail Transfer Service Ready
    S: HELO USC-ISIF.ARPA
    R: 250 BERKELEY.ARPA
    S: MAIL FROM:<Postel@USC-ISIF.ARPA>
    R: 250 OK
    S: RCPT TO:<fabry@BERKELEY.ARPA>
    R: 250 OK
    S: RCPT TO:<eric@BERKELEY.ARPA>
    R: 552 Recipient storage full, try again in another transaction
    S: DATA
    R: 354 Start mail input; end with <CRLF>.<CRLF>
    S: Blah blah blah...
    S: ...etc. etc. etc.
    S: .
    R: 250 OK
    S: MAIL FROM:<Postel@USC-ISIF.ARPA>
    R: 250 OK
    S: RCPT TO:<eric@BERKELEY.ARPA>
    R: 250 OK
    S: DATA
    R: 354 Start mail input; end with <CRLF>.<CRLF>
    S: Blah blah blah...
    S: ...etc. etc. etc.
    S: .
    R: 250 OK
    S: QUIT
    R: 221 BERKELEY.ARPA Service closing transmission channel
    ```

---

# Glossary

* ASCII : 정보 교환을 위한 미국 표준 코드 1
* command : sender-SMTP에 의해 receiver-SMTP로 전송되는 메일 서비스 동작에 대한 요청.
* domain : 메일 시스템에서 호스트 컴퓨터의 계층적으로 구성된 문자열 주소.
* end of mail data indication : 메일 데이터의 끝을 나타내는 특수한 문자 시퀀스. 5자로 구성되며 CR, LF, . , CR, LF 순.
* host : 메일박스 또는 SMTP 프로세스가 있는 인터넷 작업 환경의 컴퓨터.
* line : <CRLF>로 끝나는 일련의 ASCII 문자열.
* mail data : ARPA 인터넷 문자 메시지 형식 표준을 준수하는 임의 길이의 ASCII 문자 시퀀스.
* mail box : 메일을 보낼 사용자를 식별하는 문자열(주소). 메일박스는 호스트 및 사용자로 구성됨. 표준 메일박스 명명 규칙은 "user@domain"으로 정의되고, 메일이 저장되는 "컨테이너"가 존재.
* receiver-SMTP process : sender-SMTP 프로세스와 협력하여 메일을 전송하는 프로세스. 전송 서비스를 통해 연결될 때까지 대기. sender-SMTP로부터 SMTP 명령을 수신하고, 응답을 보내고, 지정된 동작을 수행.
* reply : 응답은 명령에 대한 결과로 전송 채널을 통해 수신자로부터 발신자에게 전송.
* sender-SMTP process : receiver-SMTP 프로세스와 협력하여 메일을 전송하는 프로세스. 로컬 언어는 사용자 인터페이스 명령/응답 대화에서 사용될 수 있음. 발신자-SMTP는 전송 서비스 연결을 시작. SMTP 명령을 시작하고, 응답을 받고, 메일 전송을 관리.
* session : 전송 채널이 열려 있는 동안 발생하는 교환 세트.
* transaction : 하나 이상의 수신자에 대해 하나의 메시지를 전송하는 데 필요한 교환 세트.
* transmission channel : 명령, 응답 및 메일 텍스트 교환을위한 sender-SMTP와 receiver-SMTP 간의 전이중 통신 경로.
* transport service :  NCP, TCP, NITS등의 안정적인 스트림 지향 데이터 통신 서비스.
* user : 메일 전송 서비스를 받으려는 사람(또는 사람을 대신하는 프로세스). 또한 컴퓨터 메일을 받는 수신자.
* word : 문자를 인쇄하는 순서.
* <CRLF> : 캐릭터 캐리지 리턴과 라인 피드.
* <SP> : 공백 문자.

---

# References

* ASCII
> ASCII, "USA Code for Information Interchange", United States of
America Standards Institute, X3.4, 1968. Also in: Feinler, E.
and J. Postel, eds., "ARPANET Protocol Handbook", NIC 7104, for
the Defense Communications Agency by SRI International, Menlo
Park, California, Revised January 1978.

* RFC - 822
> Crocker, D., "Standard for the Format of ARPA Internet Text
Messages," RFC 822, Department of Electrical Engineering,
University of Delaware, August 1982.

* TCP
> Postel, J., ed., "Transmission Control Protocol - DARPA Internet
Program Protocol Specification", RFC 793, USC/Information Sciences
Institute, NTIS AD Number A111091, September 1981. Also in:
Feinler, E. and J. Postel, eds., "Internet Protocol Transition
Workbook", SRI International, Menlo Park, California, March 1982.

* NCP
> McKenzie,A., "Host/Host Protocol for the ARPA Network", NIC 8246,
January 1972. Also in: Feinler, E. and J. Postel, eds., "ARPANET
Protocol Handbook", NIC 7104, for the Defense Communications
Agency by SRI International, Menlo Park, California, Revised
January 1978.

* Initial Connection Protocol
> Postel, J., "Official Initial Connection Protocol", NIC 7101,
11 June 1971. Also in: Feinler, E. and J. Postel, eds., "ARPANET
Protocol Handbook", NIC 7104, for the Defense Communications
Agency by SRI International, Menlo Park, California, Revised
January 1978.

* NITS
> PSS/SG3, "A Network Independent Transport Service", Study Group 3,
The Post Office PSS Users Group, February 1980. Available from
the DCPU, National Physical Laboratory, Teddington, UK.

* X.25
> CCITT, "Recommendation X.25 - Interface Between Data Terminal
Equipment (DTE) and Data Circuit-terminating Equipment (DCE) for
Terminals Operating in the Packet Mode on Public Data Networks,"
CCITT Orange Book, Vol. VIII.2, International Telephone and
Telegraph Consultative Committee, Geneva, 1976.
